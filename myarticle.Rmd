---
title: "R Notebook"
output: github_document
---
Introduction:
Les diatomées sont de minuscules algues qui vivent presque partout près de la surface des océans, des lacs et des rivières. Ils restent près de la surface car, comme toute plante, ils ont besoin de lumière pour produire de l’énergie par le biais du processus de photosynthèse
Les interactions entre les diatomées et les bactéries façonnent la dynamique des communautés microbiennes et ont d’importantes implications écologiques, car elles influencent les processus biologiques et chimiques qui structurent le réseau trophique marin et régissent le cycle biogéochimique. (Falkowski et coll., 1998; Field et al., 1998; Liu et coll., 2019; Le Reun et al., 2022).

 Les diatomées exsudent du carbone organique dissous (COD) qui alimente la croissance des bactéries hétérotrophes, qui reminéralisent ensuite ces composés organiques et favorisent ainsi potentiellement la production primaire (Azam et Malfatti, 2007; Falkowski et coll., 2008; Worden et coll., 2015).
Méthode:
Ils ont isolé et identifié la diatomée Actinocyclus sp. ainsi que ses bactéries associées par séquençage et microscopie. Ils ont ensuite créé une culture axénique puis testé différentes souches bactériennes en co-culture pour observer leur effet sur la croissance de la diatomée, suivie par cytométrie en flux et analyses statistiques.

Objectif de l’étude
L’étude visait à savoir quelles bactéries stimulent la croissance de Actinocyclus, dans quelle mesure et à quel moment du cycle de vie ces effets se produisent.
```{r}
library(dada2); packageVersion("dada2")
```
```{r}
path <- "~/myarticle" # CHANGE ME to the directory containing the fastq files after unzipping.
list.files(path)
#Apres installation de dada2, Ce code indique à R où se trouvent mes fichiers de séquençage, puis affiche tout ce qu’il y a dans ce dossier pour vérifier que tout est prêt avant l’analyse. C’est une façon rapide de vérifier que R “voit” bien mes fichiers FASTQ, avant de les traiter avec dada2.
#On peut voir ci dessus qu'après avoir lancé le code, j'ai obtenue la liste des sequences présent dans mon fichier
```
```{r}
# Forward and reverse fastq filenames have format: SAMPLENAME_R1_001.fastq and SAMPLENAME_R2_001.fastq
fnFs <- sort(list.files(path, pattern="_1.fastq", full.names = TRUE))
fnRs <- sort(list.files(path, pattern="_2.fastq", full.names = TRUE))
# Extract sample names, assuming filenames have format: SAMPLENAME_XXX.fastq
sample.names <- sapply(strsplit(basename(fnFs), "_"), `[`, 1)
#Ce code repère automatiquement les fichiers FASTQ “forward” et “reverse” dans mon dossier, puis extrait proprement les noms d’échantillons à partir de leurs noms de fichiers.
#Cela permet à R (et à DADA2) de savoir quel fichier correspond à quel échantillon avant de commencer le traitement des séquences.
```
```{r}
plotQualityProfile(fnFs[1:2])
#Cette commande affiche un graphique de la qualité des bases d’ADN pour tes deux premiers fichiers de séquençage “forward”.fnFs = ma liste de fichiers FASTQ “forward” (R1).fnFs[1:2] → prend les deux premiers fichiers de cette liste (pour ne pas tout afficher d’un coup),plotQualityProfile() → crée un graphique qui montre la qualité des bases (A, T, C, G) le long des séquences.
#Elle te permet de voir où la qualité commence à se dégrader et d’ajuster ensuite le nettoyage de tes données en conséquence.
#sur le grave on peut voir que la qualité commence à se degrader à partir de Q=270 pour les séquences forwards
```
```{r}
plotQualityProfile(fnRs[1:2])
#Cette commande trace le profil de qualité des deux premiers fichiers de séquences reverse.
#Cela te permet de comparer la qualité avec les lectures forward et de décider comment nettoyer (couper ou filtrer) ces lectures avant l’analyse DADA2.
#sur le grave on peut voir que la qualité commence à se degrader à partir de Q=250 pour les séquences reverses
```



5
```{r}
# Place filtered files in filtered/ subdirectory
filtFs <- file.path(path, "filtered", paste0(sample.names, "_F_filt.fastq.gz"))
filtRs <- file.path(path, "filtered", paste0(sample.names, "_R_filt.fastq.gz"))
names(filtFs) <- sample.names
names(filtRs) <- sample.names
#Ce code prépare la structure pour sauvegarder les fichiers FASTQ filtrés (après nettoyage).
#Il crée des chemins vers un dossier filtered/ où seront enregistrées les versions “propres” des séquences forward et reverse, et associe chaque fichier à son échantillon correspondant.filtRs contient les chemins des fichiers “reverse” filtrés,filtFs contient les chemins complets vers les fichiers “forward” filtrés qui seront créés plus tard.
```
```{r}
out <- filterAndTrim(fnFs, filtFs, fnRs, filtRs, truncLen=c(270,250),
              maxN=0, maxEE=c(2,2), truncQ=2, rm.phix=TRUE,
              compress=TRUE, multithread=FALSE) # On Windows set multithread=FALSE
head(out)
#Après le plotQualityProfile on abtenue les scores de qualité ^puis on utilise ces données pour ce code pour filtrer mes fichiers
#Ce code lit tes fichiers FASTQ, élimine les séquences de mauvaise qualité, coupe les lectures aux bonnes longueurs, et enregistre les versions “propres” dans un dossier filtered/.
#Le tableau out te dit combien de lectures ont survécu au filtrage pour chaque échantillon.
```
```{r}
errF <- learnErrors(filtFs, multithread=TRUE)
#Avant de “deviner” les vraies séquences d’ADN, DADA2 doit comprendre à quoi ressemblent les erreurs introduites par la machine de séquençage (Illumina, par exemple).
#Cette commande apprend à DADA2 à reconnaître les erreurs de séquençage dans les fichiers forward.
#En gros, le logiciel regarde comment la machine se trompe, pour ensuite pouvoir “nettoyer” les séquences de manière intelligente.
#C’est une étape de calibration : on apprend le “style d’erreur” du séquenceur avant de corriger les données.
```
```{r}
errR <- learnErrors(filtRs, multithread=TRUE)
#c'est le même principe avec le code précédent 
#Cette commande apprend à DADA2 comment les lectures “reverse” se trompent.
#Elle construit un modèle d’erreurs spécifique à ces fichiers pour que le logiciel puisse ensuite distinguer les vraies séquences biologiques des erreurs techniques.
#En gros : DADA2 “apprend à reconnaître les fautes” dans tes données reverse.
```
```{r}
plotErrors(errF, nominalQ=TRUE)
#Cette commande affiche un graphique qui te montre comment DADA2 comprend les erreurs de séquençage dans tes lectures “forward”.
#Si les points (observations réelles) suivent bien les lignes rouges (modèle), cela veut dire que ton modèle d’erreurs est fiable et prêt à être utilisé pour corriger les séquences.
```
```{r}
dadaFs <- dada(filtFs, err=errF, multithread=TRUE)
#Jusqu’ici, j'ai :
#Filtré et nettoyé les séquences,
#Appris le modèle d’erreurs,
#Vérifié ce modèle (plotErrors()).
#Maintenant, DADA2 va utiliser ce modèle d’erreurs pour identifier les “vraies” séquences biologiques présentes dans tes données, en corrigeant les erreurs de séquençage.
#Cette commande fait le “cerveau” du pipeline DADA2 :
#elle lit les séquences filtrées forward, corrige les erreurs en se basant sur le modèle appris (errF), et en déduit quelles sont les vraies séquences d’ADN présentes dans ton échantillon.
#Le résultat (dadaFs) contient les séquences uniques et propres qui reflètent la réalité biologique, pas les fautes du séquenceur.
```
```{r}
dadaRs <- dada(filtRs, err=errR, multithread=TRUE)
#Cette commande fait pour les lectures “reverse” ce que je viens de faire pour les “forward” :
#elle utilise le modèle d’erreurs (errR) pour corriger les fautes du séquenceur et identifier les vraies séquences biologiques présentes dans chaque échantillon.
```
```{r}
dadaFs[[1]]
#Cette commande te montre les résultats de la correction d’erreurs pour ton premier échantillon forward.
#Elle affiche combien de lectures ont été traitées et combien de séquences uniques (ASVs) ont été trouvées.
#En gros, c’est un aperçu du “nettoyage” réussi de mes données de séquençage.
```
```{r}
mergers <- mergePairs(dadaFs, filtFs, dadaRs, filtRs, verbose=TRUE)
# Inspect the merger data.frame from the first sample
head(mergers[[1]])
#Cette étape fusionne les lectures avant et arrière pour chaque échantillon.
#DADA2 garde uniquement les paires qui se chevauchent correctement et sans trop d’erreurs.
#Le tableau affiché te montre les premières séquences fusionnées du premier échantillon, avec des infos sur leur qualité et leur fréquence.
```
```{r}
seqtab <- makeSequenceTable(mergers)
dim(seqtab)
#Ce code regroupe toutes tes séquences fusionnées dans une grande table d’abondances, où chaque colonne représente une séquence unique (ASV) et chaque ligne un échantillon.
#dim(seqtab) te dit combien d’échantillons et combien de séquences différentes tu as obtenus dans ton jeu de données final.
```
```{r}
# Inspect distribution of sequence lengths
table(nchar(getSequences(seqtab)))
#Cette commande compte combien de séquences uniques ont une certaine longueur.
#C’est un contrôle qualité rapide pour vérifier que toutes les séquences inférées ont la taille attendue pour ton gène cible
```
```{r}
seqtab.nochim <- removeBimeraDenovo(seqtab, method="consensus", multithread=TRUE, verbose=TRUE)
dim(seqtab.nochim)
#Ce code nettoie ta table finale en supprimant les séquences artificielles issues d’erreurs de PCR.
#Le résultat (seqtab.nochim) contient uniquement les vraies séquences biologiques fiables, prêtes pour l’analyse taxonomique.
```
```{r}
sum(seqtab.nochim)/sum(seqtab)
#Cette commande calcule la proportion de lectures qui restent valides après suppression des séquences chimériques.
#Elle te donne une idée de la qualité finale de ton jeu de données : plus le pourcentage est élevé, plus ton échantillon est propre.
```
```{r}
getN <- function(x) sum(getUniques(x))
track <- cbind(out, sapply(dadaFs, getN), sapply(dadaRs, getN), sapply(mergers, getN), rowSums(seqtab.nochim))
# If processing a single sample, remove the sapply calls: e.g. replace sapply(dadaFs, getN) with getN(dadaFs)
colnames(track) <- c("input", "filtered", "denoisedF", "denoisedR", "merged", "nonchim")
rownames(track) <- sample.names
head(track)
#Ce code crée un tableau de suivi qui montre combien de lectures ont survécu à chaque étape du pipeline DADA2 — depuis les fichiers bruts jusqu’aux séquences finales sans chimères.
```
```{r}
taxa <- assignTaxonomy(seqtab.nochim, "~/silva_nr99_v138.2_toSpecies_trainset.fa.gz?download=1", multithread=TRUE)
#Cette commande “donne un nom” à chaque séquence d’ADN détectée dans tes échantillons, en identifiant à quel type de bactérie elle appartient, pour que tu puisses analyser la composition microbienne.
```
```{r}
taxa.print <- taxa # Removing sequence rownames for display only
rownames(taxa.print) <- NULL
head(taxa.print)
#Ce code te montre les noms des bactéries (taxonomie) assignés à chaque séquence dans un format lisible.
#Tu peux maintenant voir quels genres ou familles sont présents dans tes échantillons.
```
```{r}
library(DECIPHER); packageVersion("DECIPHER")
```
```{r}
dna <- DNAStringSet(getSequences(seqtab.nochim)) # Create a DNAStringSet from the ASVs
load("~/SILVA_SSU_r138_2_2024.RData") # CHANGE TO THE PATH OF YOUR TRAINING SET
ids <- IdTaxa(dna, trainingSet, strand="top", processors=NULL, verbose=FALSE) # use all processors
ranks <- c("domain", "phylum", "class", "order", "family", "genus", "species") # ranks of interest
# Convert the output object of class "Taxa" to a matrix analogous to the output from assignTaxonomy
taxid <- t(sapply(ids, function(x) {
        m <- match(ranks, x$rank)
        taxa <- x$taxon[m]
        taxa[startsWith(taxa, "unclassified_")] <- NA
        taxa
}))
colnames(taxid) <- ranks; rownames(taxid) <- getSequences(seqtab.nochim)
#Ce code prend tes séquences ASV propres, les compare à un jeu de référence SILVA avec DECIPHER, et construit une table de taxonomie indiquant le domaine, phylum, classe, ordre, famille, genre et espèce pour chaque séquence.
#C’est une manière plus fine et parfois plus précise que assignTaxonomy() pour identifier les bactéries de tes échantillons.
```
```{r}
rownames(seqtab.nochim)

```


```{r}
library(phyloseq); packageVersion("phyloseq")
#Cette commande prépare R pour utiliser phyloseq, un package qui te permettra de regrouper toutes tes données (ASVs, taxonomie, échantillons, arbres) dans un seul objet et de les analyser facilement, notamment pour calculer la diversité microbienne et produire des graphiques.
```
```{r}
library(Biostrings); packageVersion("Biostrings")
#Ce code charge Biostrings, un package de base pour manipuler et analyser les séquences d’ADN, d’ARN ou de protéines dans R.
#Il te fournit les outils nécessaires pour gérer les séquences ASV que tu as générées avec DADA2 et éventuellement pour créer un arbre phylogénétique plus tard.
```
```{r}
library(ggplot2); packageVersion("ggplot2")
#Cette commande prépare R pour créer des graphiques de haute qualité avec tes données microbiologiques.
#C’est l’outil idéal pour visualiser la composition des échantillons, les différences entre conditions, ou la diversité microbienne de manière claire et esthétique
```
```{r}
theme_set(theme_bw())
#Cette commande configure ggplot2 pour que tous les graphiques que tu crées aient un style clair et épuré, avec un fond blanc et des axes noirs, prêt pour les rapports ou publications.
```

```{r}
# 1. Lire les métadonnées
metadata <- read.csv("~/myarticle/SraRunTable.csv", header=TRUE, sep = ";", row.names = 1)
metadata
#Ici je dis à R de lire mes méta-données et de les stoker dans metadata
```


```{r}
ps <- phyloseq(otu_table(seqtab.nochim, taxa_are_rows=FALSE),
               sample_data(metadata),
               tax_table(taxa)
)
#Ce code crée un objet phyloseq complet avec tes données :les ASVs et leur abondance,les taxonomies,les métadonnées des échantillons.
```

#ce code crée un objet phyloseq complet et prêt à l’analyse en intégrant les séquences d’ADN de chaque ASV (converties en DNAStringSet), les abondances dans chaque échantillon, la taxonomie et les métadonnées. Les noms d’ASVs sont simplifiés en ASV1, ASV2, etc., pour faciliter la manipulation et la lecture. Résultat : un objet structuré contenant toutes les informations nécessaires pour analyser, visualiser et comparer la composition microbienne de tes échantillons.
```{r}
dna <- Biostrings::DNAStringSet(taxa_names(ps))
names(dna) <- taxa_names(ps)
ps <- merge_phyloseq(ps, dna)
taxa_names(ps) <- paste0("ASV", seq(ntaxa(ps)))
ps
```

#Ce graphique montre la diversité interne de chaque échantillon selon deux indices différents, en fonction du source d'isolation et des hotes
#C’est un moyen simple de visualiser si la diversité microbienne change en fonction des sources d'isolation ou entre groupes.
```{r}
plot_richness(ps, x="isolation_source", measures=c("Shannon", "Simpson"), color="HOST")
```

#Ce code prépare les données pour comparer les échantillons entre eux en termes de composition microbienne.
#Les comptages sont transformés en proportions, puis une ordination NMDS est calculée avec la distance de Bray-Curtis, permettant de visualiser les similitudes et différences globales entre échantillons dans un espace 2D ou 3D.
```{r}
# Transform data to proportions as appropriate for Bray-Curtis distances
ps.prop <- transform_sample_counts(ps, function(otu) otu/sum(otu))
ord.nmds.bray <- ordinate(ps.prop, method="NMDS", distance="bray")
```

#Ce graphique montre comment les échantillons se regroupent ou se séparent selon leur composition microbienne, en mettant en évidence les différences entre LE HOST ET LA SOURCE D'ISOLATION.
#C’est un moyen simple et visuel de détecter les patterns globaux dans tes données de microbiome.
```{r}
plot_ordination(ps.prop, ord.nmds.bray, color="HOST", title="Bray NMDS")
```



#Regroupe toutes les séquences en grandes catégories appelées "Classes".

#Choisit seulement les 20 classes les plus abondantes pour ne pas surcharger le graphique.

#Transforme les valeurs en pourcentages, pour pouvoir comparer les échantillons entre eux.

#Crée un graphique en barres empilées où chaque couleur représente une classe microbienne.

#Sépare le graphique en plusieurs colonnes selon la source d’isolement des échantillons (exemple : eau, sol, intestin…).

#Améliore l’apparence du graphique (titres lisibles, étiquettes inclinées, organisation propre).
#Le résultat final est un barplot comparatif montrant la structure taxonomique des échantillons en fonction de leur source d’isolement.
#on peut voir que dans le plot obtenue les différents micro organismes 
```{r}

library(grid)

# 1) Agglomérer par Class
ps_class <- tax_glom(ps, taxrank = "Class")

# 2) Top 20 classes (selon abondance totale)
top20_classes <- names(sort(taxa_sums(ps_class), decreasing = TRUE))[1:20]

# 3) Garder uniquement le top 20
ps_class_top20 <- prune_taxa(top20_classes, ps_class)

# 4) Abondances relatives
ps_class_top20 <- transform_sample_counts(ps_class_top20, function(x) x / sum(x))

# 5) Barplot + facettes avec entêtes "wrap" (retour à la ligne)
p <- plot_bar(ps_class_top20, fill = "Class") +
  geom_bar(stat = "identity", width = 0.7) +
  facet_grid(
    ~ isolation_source,
    scales = "free_x",
    space  = "free",
    labeller = labeller(isolation_source= label_wrap_gen(width = 12)) # <-- ajuste 10/12/15
  ) +
  theme_bw() +
  theme(
    panel.spacing = unit(0.8, "lines"),
    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, size = 8),
    axis.text.y = element_text(size = 9),
    axis.title  = element_text(size = 10),
    
    # entêtes des facettes
    strip.text.x = element_text(face = "bold", size = 9, lineheight = 1.0),
    strip.background = element_rect(fill = "grey95", colour = "grey60"),
    
    # marges (pour éviter tout effet de coupe)
    plot.margin = margin(10, 10, 10, 10),
    
    legend.text  = element_text(size = 8),
    legend.title = element_text(size = 9)
  ) +
  ylab("Abondance relative") +
  xlab("Échantillons") +
  guides(fill = guide_legend(title = "Classe"))

p
    
```


